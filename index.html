<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3dvr.tech Jetpack Game – Sacred Level</title>
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Reset margins and hide scrollbars */
    body { margin: 0; overflow: hidden; }

    /* Minimal, modern HUD for score & instructions */
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      font-family: sans-serif;
      font-size: 16px;
      z-index: 20;
    }

    /* Mobile on‑screen controls styling */
    #dpad {
      position: fixed;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
    }
    #dpad > div {
      display: flex;
      justify-content: center;
    }
    #dpad button,
    #fly-btn {
      width: 60px;
      height: 60px;
      font-size: 24px;
      margin: 5px;
      opacity: 0.8;
      border: none;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
    }
    /* Fly button at bottom-right */
    #fly-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <!-- HUD for score -->
  <div id="hud">Score: 0</div>

  <!-- Mobile on‑screen controls -->
  <div id="dpad">
    <button id="up-btn">↑</button>
    <div>
      <button id="left-btn">←</button>
      <button id="down-btn">↓</button>
      <button id="right-btn">→</button>
    </div>
  </div>
  <button id="fly-btn">Fly</button>

  <!-- Load Three.js and GLTFLoader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- All-in-one game code -->
  <script>
    /**
     * 3dvr.tech Jetpack Game – Sacred Level
     *
     * This level uses sacred geometry and the golden ratio to generate
     * a winding, golden‑spiral path of 3dvr.tech billboards. When the player
     * (a jetpack-equipped glTF model) “collides” with these billboards, they disappear,
     * awarding points. Modern UX/UI principles guide our HUD and mobile controls.
     */

    // GLOBAL VARIABLES
    let scene, camera, renderer, clock;
    let player, playerVelocity;
    let billboards = [];      // Extra floating decorations (if any)
    let pathBillboards = [];  // Billboards along the golden spiral path
    const keys = {};         // For keyboard & mobile button states
    let score = 0;           // Player score

    // Physics & control constants
    const GRAVITY    = new THREE.Vector3(0, -9.8, 0);
    const THRUST     = 20;
    const MOVE_ACCEL = 10;
    const MAX_SPEED  = 50;

    // INITIALIZE THE SCENE
    function init() {
      // Create scene, camera, renderer, and clock
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 5, 15);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      clock = new THREE.Clock();

      // Add lighting (ambient and directional)
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);

      // Ground plane
      const groundGeo = new THREE.PlaneGeometry(200, 200);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // Optional: Add extra floating 3dvr.tech billboards (for decoration)
      addBrandBillboards();

      // Create our sacred path – a golden spiral of 3dvr.tech billboards
      createGoldenSpiralPath();

      // Setup event listeners
      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('keyup', onKeyUp, false);
      initMobileControls();

      // Load the player model (or fallback)
      loadPlayer();
    }

    // MOBILE CONTROLS – map on‑screen buttons to key states
    function initMobileControls() {
      // Left
      let leftBtn = document.getElementById("left-btn");
      leftBtn.addEventListener("touchstart", e => { e.preventDefault(); keys["a"] = true; });
      leftBtn.addEventListener("touchend", e => { e.preventDefault(); keys["a"] = false; });
      leftBtn.addEventListener("mousedown", e => { e.preventDefault(); keys["a"] = true; });
      leftBtn.addEventListener("mouseup", e => { e.preventDefault(); keys["a"] = false; });
      // Right
      let rightBtn = document.getElementById("right-btn");
      rightBtn.addEventListener("touchstart", e => { e.preventDefault(); keys["d"] = true; });
      rightBtn.addEventListener("touchend", e => { e.preventDefault(); keys["d"] = false; });
      rightBtn.addEventListener("mousedown", e => { e.preventDefault(); keys["d"] = true; });
      rightBtn.addEventListener("mouseup", e => { e.preventDefault(); keys["d"] = false; });
      // Up
      let upBtn = document.getElementById("up-btn");
      upBtn.addEventListener("touchstart", e => { e.preventDefault(); keys["w"] = true; });
      upBtn.addEventListener("touchend", e => { e.preventDefault(); keys["w"] = false; });
      upBtn.addEventListener("mousedown", e => { e.preventDefault(); keys["w"] = true; });
      upBtn.addEventListener("mouseup", e => { e.preventDefault(); keys["w"] = false; });
      // Down
      let downBtn = document.getElementById("down-btn");
      downBtn.addEventListener("touchstart", e => { e.preventDefault(); keys["s"] = true; });
      downBtn.addEventListener("touchend", e => { e.preventDefault(); keys["s"] = false; });
      downBtn.addEventListener("mousedown", e => { e.preventDefault(); keys["s"] = true; });
      downBtn.addEventListener("mouseup", e => { e.preventDefault(); keys["s"] = false; });
      // Fly (jetpack thrust)
      let flyBtn = document.getElementById("fly-btn");
      flyBtn.addEventListener("touchstart", e => { e.preventDefault(); keys[" "] = true; });
      flyBtn.addEventListener("touchend", e => { e.preventDefault(); keys[" "] = false; });
      flyBtn.addEventListener("mousedown", e => { e.preventDefault(); keys[" "] = true; });
      flyBtn.addEventListener("mouseup", e => { e.preventDefault(); keys[" "] = false; });
    }

    // LOAD THE PLAYER MODEL (glTF) OR FALL BACK TO A SPHERE
    function loadPlayer() {
      const loader = new THREE.GLTFLoader();
      loader.load(
        'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
        function(gltf) {
          player = gltf.scene;
          player.scale.set(0.5, 0.5, 0.5);
          player.position.set(0, 2, 0);
          // Attach a jetpack flame
          const flameGeo = new THREE.ConeGeometry(0.2, 0.5, 8);
          const flameMat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
          const flameMesh = new THREE.Mesh(flameGeo, flameMat);
          flameMesh.position.set(0, -0.8, 0);
          flameMesh.rotation.x = Math.PI;
          flameMesh.visible = false;
          flameMesh.name = "flame";
          player.add(flameMesh);
          // Add a small 3dvr.tech branding billboard above the model
          addPlayerBranding();
          scene.add(player);
          playerVelocity = new THREE.Vector3();
          animate();
        },
        undefined,
        function(error) {
          console.error("Error loading model", error);
          // Fallback: simple red sphere with a flame
          player = new THREE.Object3D();
          const bodyGeo = new THREE.SphereGeometry(0.5, 16, 16);
          const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
          player.add(bodyMesh);
          const flameGeo = new THREE.ConeGeometry(0.2, 0.5, 8);
          const flameMat = new THREE.MeshBasicMaterial({ color: 0xffa500 });
          const flameMesh = new THREE.Mesh(flameGeo, flameMat);
          flameMesh.position.set(0, -0.8, 0);
          flameMesh.rotation.x = Math.PI;
          flameMesh.visible = false;
          flameMesh.name = "flame";
          player.add(flameMesh);
          addPlayerBranding();
          player.position.set(0, 2, 0);
          scene.add(player);
          playerVelocity = new THREE.Vector3();
          animate();
        }
      );
    }

    // ADD A BILLBOARD TO THE PLAYER (for branding)
    function addPlayerBranding() {
      const branding = createBillboard("3dvr.tech");
      branding.scale.set(0.5, 0.5, 0.5);
      branding.position.set(0, 2, 0);
      branding.name = "branding";
      player.add(branding);
    }

    // ADD EXTRA FLOATING 3dvr.tech BILLBOARDS (for decoration)
    function addBrandBillboards() {
      const positions = [
        { x: 10,  y: 5, z: -20 },
        { x: -15, y: 3, z: 30 },
        { x: 20,  y: 6, z: 15 },
        { x: -25, y: 4, z: -10 },
        { x: 5,   y: 8, z: -5 },
        { x: -10, y: 6, z: 10 }
      ];
      positions.forEach(pos => {
        const billboard = createBillboard("3dvr.tech");
        billboard.position.set(pos.x, pos.y, pos.z);
        scene.add(billboard);
        billboards.push(billboard);
      });
    }

    // CREATE A BILLBOARD MESH (using a text canvas)
    function createBillboard(text) {
      const canvas = document.createElement('canvas');
      const size = 256;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, size, size);
      ctx.font = "40px Arial";
      ctx.fillStyle = "#000000";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, size / 2, size / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
      const geometry = new THREE.PlaneGeometry(5, 5);
      return new THREE.Mesh(geometry, material);
    }

    // CREATE A GOLDEN SPIRAL PATH OF 3dvr.tech BILLBOARDS
    function createGoldenSpiralPath() {
      // Use a logarithmic spiral: r = a * exp(b * theta)
      // For a golden spiral, when theta increases by π/2, r multiplies by the golden ratio φ
      const phi = 1.618;
      const a = 1;
      const b = Math.log(phi) / (Math.PI / 2);
      const numBillboards = 15;
      const maxTheta = 6 * Math.PI;
      for (let i = 0; i < numBillboards; i++) {
        const theta = (i / (numBillboards - 1)) * maxTheta;
        const r = a * Math.exp(b * theta);
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        // Add a slight vertical oscillation for extra interest
        const y = 2 + Math.sin(theta * 0.5);
        const billboard = createBillboard("3dvr.tech");
        billboard.scale.set(0.8, 0.8, 0.8);
        billboard.position.set(x, y, z);
        scene.add(billboard);
        pathBillboards.push(billboard);
      }
    }

    // CHECK FOR COLLISIONS BETWEEN THE PLAYER AND THE PATH BILLBOARDS
    function checkCollisions() {
      if (!player) return;
      const playerPos = player.position;
      // For each billboard along the golden spiral path…
      for (let i = pathBillboards.length - 1; i >= 0; i--) {
        const billboard = pathBillboards[i];
        const distance = playerPos.distanceTo(billboard.position);
        if (distance < 2) { // collision threshold
          scene.remove(billboard);
          pathBillboards.splice(i, 1);
          score += 10;
          updateHUD();
        }
      }
    }

    // UPDATE THE HUD (score display)
    function updateHUD() {
      const hud = document.getElementById("hud");
      hud.textContent = "Score: " + score;
    }

    // EVENT HANDLERS
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onKeyDown(e) { keys[e.key] = true; }
    function onKeyUp(e) { keys[e.key] = false; }

    // ANIMATION LOOP
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      updatePlayer(delta);
      checkCollisions();
      // Ensure all billboards face the camera
      billboards.forEach(b => b.lookAt(camera.position));
      pathBillboards.forEach(b => b.lookAt(camera.position));
      renderer.render(scene, camera);
    }

    // UPDATE PLAYER MOVEMENT & CAMERA FOLLOW
    function updatePlayer(delta) {
      let acceleration = new THREE.Vector3().copy(GRAVITY);
      if (keys[" "] || keys["Spacebar"]) {
        acceleration.y += THRUST;
        const flame = player.getObjectByName("flame");
        if (flame) flame.visible = true;
      } else {
        const flame = player.getObjectByName("flame");
        if (flame) flame.visible = false;
      }
      if (keys["w"] || keys["W"] || keys["ArrowUp"]) acceleration.z -= MOVE_ACCEL;
      if (keys["s"] || keys["S"] || keys["ArrowDown"]) acceleration.z += MOVE_ACCEL;
      if (keys["a"] || keys["A"] || keys["ArrowLeft"]) acceleration.x -= MOVE_ACCEL;
      if (keys["d"] || keys["D"] || keys["ArrowRight"]) acceleration.x += MOVE_ACCEL;
      playerVelocity.addScaledVector(acceleration, delta);
      if (playerVelocity.length() > MAX_SPEED) playerVelocity.setLength(MAX_SPEED);
      player.position.addScaledVector(playerVelocity, delta);
      const minHeight = 1;
      if (player.position.y < minHeight) {
        player.position.y = minHeight;
        playerVelocity.y = 0;
      }
      playerVelocity.multiplyScalar(0.99);
      // Smoothly update camera to follow the player
      const desiredCameraPos = new THREE.Vector3(
        player.position.x,
        player.position.y + 5,
        player.position.z + 10
      );
      camera.position.lerp(desiredCameraPos, 0.1);
      camera.lookAt(player.position);
    }

    // START THE GAME
    init();
  </script>
</body>
</html>
