<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3dvr.tech Jetpack Game</title>
  <!-- Ensure proper scaling on mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Remove default margins and hide scrollbars */
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <!-- Load Three.js from a CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Load the GLTFLoader for loading 3D models -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <!-- All game code -->
  <script>
    // === GLOBAL VARIABLES ===
    let scene, camera, renderer, clock;
    let player, playerVelocity;
    let billboards = [];  // Array for 3dvr.tech billboards
    let touchStart = null; // For mobile touch controls

    // Physics and control constants
    const GRAVITY    = new THREE.Vector3(0, -9.8, 0);
    const THRUST     = 20;
    const MOVE_ACCEL = 10;
    const MAX_SPEED  = 50;
    const keys = {};  // Track key states

    // === INITIALIZATION FUNCTION ===
    function init() {
      // Create scene and set background color
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      // Create camera
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.set(0, 5, 15);

      // Create renderer and add its canvas to the page
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Set up a clock for delta timing
      clock = new THREE.Clock();

      // Add ambient and directional lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);

      // Create a large ground plane
      const groundGeometry = new THREE.PlaneGeometry(200, 200);
      const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // Add branded billboards throughout the scene
      addBrandBillboards();

      // Set up event listeners (keyboard, touch, window resize)
      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('keyup', onKeyUp, false);
      window.addEventListener('touchstart', onTouchStart, false);
      window.addEventListener('touchmove', onTouchMove, false);
      window.addEventListener('touchend', onTouchEnd, false);

      // Load the improved player model
      loadPlayer();
    }

    // === LOAD PLAYER MODEL (GLTF) ===
    function loadPlayer() {
      const loader = new THREE.GLTFLoader();
      // Using the RobotExpressive model from Three.js examples
      loader.load(
        'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
        function(gltf) {
          player = gltf.scene;
          player.scale.set(0.5, 0.5, 0.5);
          player.position.set(0, 2, 0);
          // Add a jetpack flame (a small cone) to the model
          const flameGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
          const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
          const flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
          flameMesh.position.set(0, -0.8, 0);
          flameMesh.rotation.x = Math.PI; // Points downward
          flameMesh.visible = false;
          flameMesh.name = "flame";
          player.add(flameMesh);

          // Add a small 3dvr.tech branding above the player
          addPlayerBranding();

          // Add the player model to the scene and initialize its velocity
          scene.add(player);
          playerVelocity = new THREE.Vector3();
          // Start the render loop after the model loads
          animate();
        },
        undefined,
        function(error) {
          console.error('Error loading glTF model', error);
          // Fallback: create a simple red sphere if the model fails to load
          player = new THREE.Object3D();
          const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
          const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
          const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
          player.add(bodyMesh);

          const flameGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
          const flameMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
          const flameMesh = new THREE.Mesh(flameGeometry, flameMaterial);
          flameMesh.position.set(0, -0.8, 0);
          flameMesh.rotation.x = Math.PI;
          flameMesh.visible = false;
          flameMesh.name = "flame";
          player.add(flameMesh);

          addPlayerBranding();
          player.position.set(0, 2, 0);
          scene.add(player);
          playerVelocity = new THREE.Vector3();
          animate();
        }
      );
    }

    // === PLAYER BRANDING ===
    function addPlayerBranding() {
      const branding = createBillboard("3dvr.tech");
      branding.scale.set(0.5, 0.5, 0.5);
      branding.position.set(0, 2, 0);
      branding.name = "branding";
      player.add(branding);
    }

    // === BRANDING BILLBOARDS ===
    function addBrandBillboards() {
      const billboardPositions = [
        { x: 10,  y: 5, z: -20 },
        { x: -15, y: 3, z: 30 },
        { x: 20,  y: 6, z: 15 },
        { x: -25, y: 4, z: -10 },
        { x: 5,   y: 8, z: -5 },
        { x: -10, y: 6, z: 10 }
      ];
      billboardPositions.forEach(pos => {
        const billboard = createBillboard("3dvr.tech");
        billboard.position.set(pos.x, pos.y, pos.z);
        scene.add(billboard);
        billboards.push(billboard);
      });
    }

    // === CREATE BILLBOARD FUNCTION ===
    function createBillboard(text) {
      const canvas = document.createElement('canvas');
      const size = 256;
      canvas.width = size;
      canvas.height = size;
      const context = canvas.getContext('2d');
      context.fillStyle = "#ffffff";
      context.fillRect(0, 0, size, size);
      context.font = "40px Arial";
      context.fillStyle = "#000000";
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillText(text, size / 2, size / 2);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
        transparent: true
      });
      const geometry = new THREE.PlaneGeometry(5, 5);
      return new THREE.Mesh(geometry, material);
    }

    // === EVENT HANDLERS ===

    // Handle window resize events
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Keyboard controls
    function onKeyDown(e) {
      keys[e.key] = true;
    }
    function onKeyUp(e) {
      keys[e.key] = false;
    }

    // Touch controls for mobile devices:
    // Tapping applies thrust; dragging left/right/up/down simulates lateral movement.
    function onTouchStart(e) {
      e.preventDefault();
      touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      // Activate thrust on touch start
      keys[" "] = true;
    }
    function onTouchMove(e) {
      e.preventDefault();
      if (!touchStart) return;
      const deltaX = e.touches[0].clientX - touchStart.x;
      const deltaY = e.touches[0].clientY - touchStart.y;
      const threshold = 20; // pixels

      // Horizontal movement (simulate left/right)
      if (deltaX > threshold) {
        keys["d"] = true;
        keys["a"] = false;
      } else if (deltaX < -threshold) {
        keys["a"] = true;
        keys["d"] = false;
      } else {
        keys["a"] = false;
        keys["d"] = false;
      }

      // Vertical movement (simulate forward/backward)
      if (deltaY > threshold) {
        keys["s"] = true;
        keys["w"] = false;
      } else if (deltaY < -threshold) {
        keys["w"] = true;
        keys["s"] = false;
      } else {
        keys["w"] = false;
        keys["s"] = false;
      }
    }
    function onTouchEnd(e) {
      e.preventDefault();
      touchStart = null;
      keys[" "] = false;
      keys["a"] = false;
      keys["d"] = false;
      keys["w"] = false;
      keys["s"] = false;
    }

    // === ANIMATION LOOP ===
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      updatePlayer(delta);
      // Ensure billboards always face the camera
      billboards.forEach(billboard => {
        billboard.lookAt(camera.position);
      });
      renderer.render(scene, camera);
    }

    // === UPDATE PLAYER MOVEMENT ===
    function updatePlayer(delta) {
      // Start with gravity
      let acceleration = new THREE.Vector3().copy(GRAVITY);

      // Apply jetpack thrust if the space key (or simulated touch) is active
      if (keys[" "] || keys["Spacebar"]) {
        acceleration.y += THRUST;
        const flame = player.getObjectByName("flame");
        if (flame) flame.visible = true;
      } else {
        const flame = player.getObjectByName("flame");
        if (flame) flame.visible = false;
      }

      // Lateral movement via keyboard or touch simulation
      if (keys["w"] || keys["W"] || keys["ArrowUp"]) {
        acceleration.z -= MOVE_ACCEL;
      }
      if (keys["s"] || keys["S"] || keys["ArrowDown"]) {
        acceleration.z += MOVE_ACCEL;
      }
      if (keys["a"] || keys["A"] || keys["ArrowLeft"]) {
        acceleration.x -= MOVE_ACCEL;
      }
      if (keys["d"] || keys["D"] || keys["ArrowRight"]) {
        acceleration.x += MOVE_ACCEL;
      }

      // Update velocity based on acceleration
      playerVelocity.addScaledVector(acceleration, delta);
      if (playerVelocity.length() > MAX_SPEED) {
        playerVelocity.setLength(MAX_SPEED);
      }
      // Update player position
      player.position.addScaledVector(playerVelocity, delta);

      // Prevent the player from falling below a minimum height (ground collision)
      const minHeight = 1;
      if (player.position.y < minHeight) {
        player.position.y = minHeight;
        playerVelocity.y = 0;
      }

      // Apply damping to the velocity for smoother movement
      playerVelocity.multiplyScalar(0.99);

      // Smoothly move the camera to follow the player
      const desiredCameraPos = new THREE.Vector3(
        player.position.x,
        player.position.y + 5,
        player.position.z + 10
      );
      camera.position.lerp(desiredCameraPos, 0.1);
      camera.lookAt(player.position);
    }

    // === START THE GAME ===
    init();
  </script>
</body>
</html>
